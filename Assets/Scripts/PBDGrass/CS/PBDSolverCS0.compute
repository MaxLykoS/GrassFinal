#pragma kernel PBDSolver
#pragma kernel UpdateMesh

#define XThreads 64

struct FixedConstraintStruct
{
    int i0;
    float3 fixedPos;
};
struct DistanceConstraintStruct
{
    float RestLength;
    float ElasticModulus;
    int i0, i1;
};

struct SphereCollision
{
    float3 Position;
    float Radius;
};

float dt;

float3 Gravity;
float3 WindForce;
float Friction;
float StopThreshold;

float Mass;

RWStructuredBuffer<float3> PositionBuffer;
RWStructuredBuffer<float3> PredictedBuffer;
RWStructuredBuffer<float3> VelocitiesBuffer;
RWStructuredBuffer<float3> OriginPosBuffer;
RWStructuredBuffer<float3> OffsetBuffer;
RWStructuredBuffer<FixedConstraintStruct> FconsBuffer;
RWStructuredBuffer<DistanceConstraintStruct> DconsBuffer;
RWStructuredBuffer<int> IndexOffsetBuffer;

RWStructuredBuffer<SphereCollision> BallBuffer;

RWStructuredBuffer<float3> ResultPosBuffer;

[numthreads(XThreads, 1, 1)] // id.x body
void PBDSolver(uint3 id : SV_DispatchThreadID)
{
    // Apply Force ************
    for (int i = 0; i < 4;i++)
    {
        int idb = id.x * 4 + i;
        
        // air friction
        VelocitiesBuffer[idb] -= VelocitiesBuffer[idb] * Friction * dt;
        // gravity
        VelocitiesBuffer[idb] += Gravity * dt;
        // recovery force
        VelocitiesBuffer[idb] += (OriginPosBuffer[idb] - PredictedBuffer[idb]) * dt * 2000;
        // wind force
        VelocitiesBuffer[idb] += WindForce * dt;  
    }
    
    // Estimate Positions ***********
    for (i = 0; i < 4; i++)
    {      
        int idb = id.x * 4 + i;
        // update position with new velocity
        PredictedBuffer[idb] = PositionBuffer[idb] + dt * VelocitiesBuffer[idb];
    }
    
    // ResolveCollision *************
    uint ballCount = 0;
    uint ballStride = 0;
    BallBuffer.GetDimensions(ballCount, ballStride);
    for (i = 0; i < 4;i++)
    {
        int idb = id.x * 4 + i;
        
        for (uint j = 0; j < ballCount; j++)
        {
            float3 b2g = PredictedBuffer[idb] - BallBuffer[j].Position;
            float len = length(b2g);
            float3 b2gNormalize = normalize(b2g);
        
            float offset = len - BallBuffer[j].Radius;
            if (offset < 0)
            {
                float3 targetPos = BallBuffer[j].Position + b2gNormalize * BallBuffer[j].Radius;
                PositionBuffer[idb] = targetPos;
                PredictedBuffer[idb] = targetPos;
                VelocitiesBuffer[idb] = float3(0, 0, 0);
                break;
            }
        }
    }
    
    // Do Constraints ***************
    float stepDT = 1.0f / 4.0f;
    
    // distance constraints
    int dconsIndexOffset = id.x * 3;
    float invMass = 1.0f / Mass;
    float sum = Mass * 2.0f;
    for (i = 0; i < 4; i++)  // 4 iteration
    {
        for (int j = 0; j < 3; j++)   // 3 dcons
        {
            int i1 = DconsBuffer[dconsIndexOffset + j].i1 + id.x * 4;
            int i0 = DconsBuffer[dconsIndexOffset + j].i0 + id.x * 4;
            float3 n = PredictedBuffer[i1] - PredictedBuffer[i0];
            float d = length(n);
            n = normalize(n);

            float3 corr = DconsBuffer[dconsIndexOffset + j].ElasticModulus * n * (d - DconsBuffer[dconsIndexOffset + j].RestLength) * sum;

            PredictedBuffer[i0] += invMass * corr * stepDT;

            PredictedBuffer[i1] -= invMass * corr * stepDT;
        }
    }
    
    // fixed constraints
    PositionBuffer[FconsBuffer[id.x].i0 + id.x * 4] = FconsBuffer[id.x].fixedPos;
    PredictedBuffer[FconsBuffer[id.x].i0 + id.x * 4] = FconsBuffer[id.x].fixedPos;
    
    
    // UpdateVelocities ****************
    float threshold = StopThreshold * dt;
    for (i = 0; i < 4;i++)
    {
        int boneIndex = id.x * 4 + i;
    
        float3 dist = PredictedBuffer[boneIndex] - PositionBuffer[boneIndex];
        VelocitiesBuffer[boneIndex] = dist / dt;
        if (length(VelocitiesBuffer[boneIndex]) < threshold)
            VelocitiesBuffer[boneIndex] = float3(0, 0, 0);
    }
    
    // Update Positions ********************
    for (i = 0; i < 4;i++)
    {
        int boneIndex = id.x * 4 + i;
        PositionBuffer[boneIndex] = PredictedBuffer[boneIndex];
    }

}

[numthreads(XThreads, 1, 1)]
void UpdateMesh(uint3 id : SV_DispatchThreadID)
{
    int boneOffset = id.x * 4;
    int offsetOffset = id.x * 3;
    int index = 0;
    for (int i = 0; i < 7 - 2; i += 2)
    {
        ResultPosBuffer[i + IndexOffsetBuffer[id.x]] = PositionBuffer[boneOffset + index] + OffsetBuffer[offsetOffset + index];
        ResultPosBuffer[i + 1 + IndexOffsetBuffer[id.x]] = PositionBuffer[boneOffset + index] - OffsetBuffer[offsetOffset + index];
        ++index;
    }
    ResultPosBuffer[7 - 1 + IndexOffsetBuffer[id.x]] = PositionBuffer[boneOffset + index];
}