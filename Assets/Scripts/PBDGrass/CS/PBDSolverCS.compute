#pragma kernel PBDSolver
#pragma kernel UpdateMesh
#pragma kernel GridCulling

#define XThreads 32
#define BoneCounts 4

struct FixedConstraintStruct
{
    int i0;
    float3 fixedPos;
};
struct DistanceConstraintStruct
{
    float RestLength;
    float ElasticModulus;
    int i0, i1;
};

struct SphereCollision
{
    float3 Position;
    float Radius;
};

float dt;

float3 Gravity;
float3 WindForce;
float Friction;
float StopThreshold;

float Mass;

RWStructuredBuffer<float3> PositionBuffer;
RWStructuredBuffer<float3> PredictedBuffer;
RWStructuredBuffer<float3> VelocitiesBuffer;
RWStructuredBuffer<float3> OriginPosBuffer;
RWStructuredBuffer<float3> OffsetBuffer;
RWStructuredBuffer<FixedConstraintStruct> FconsBuffer;
RWStructuredBuffer<DistanceConstraintStruct> DconsBuffer;
RWStructuredBuffer<int> IndexOffsetBuffer;

RWStructuredBuffer<SphereCollision> BallBuffer;

RWStructuredBuffer<float3> ResultPosBuffer;

struct PBDGrid
{
    float3 pos;
    int idOffset;
};
RWStructuredBuffer<PBDGrid> GridsVisibleBuffer;

[numthreads(XThreads, 1, 1)] // GridsVisibleBuffer[id.y].idOffset + idInGroup.x body
void PBDSolver(uint3 id : SV_DispatchThreadID, uint3 idInGroup : SV_GroupThreadID)
{
    int idx = (GridsVisibleBuffer[id.y].idOffset + idInGroup.x);
    
    // Apply Force ************
    for (int i = 0; i < BoneCounts; i++)
    {
        int idb = idx * BoneCounts + i;
        
        // air friction
        VelocitiesBuffer[idb] -= VelocitiesBuffer[idb] * Friction * dt;
        // gravity
        VelocitiesBuffer[idb] += Gravity * dt;
        // recovery force
        VelocitiesBuffer[idb] += (OriginPosBuffer[idb] - PredictedBuffer[idb]) * dt * 2000;
        // wind force
        VelocitiesBuffer[idb] += WindForce * dt;
    }
    
    // Estimate Positions ***********
    for (i = 0; i < BoneCounts; i++)
    {      
        int idb = idx * BoneCounts + i;
        // update position with new velocity
        PredictedBuffer[idb] = PositionBuffer[idb] + dt * VelocitiesBuffer[idb];
    }
    
    // ResolveCollision *************
    uint ballCount = 0;
    uint ballStride = 0;
    BallBuffer.GetDimensions(ballCount, ballStride);
    for (i = 0; i < BoneCounts; i++)
    {
        int idb = idx * BoneCounts + i;
        
        for (uint j = 0; j < ballCount; j++)
        {
            float3 b2g = PredictedBuffer[idb] - BallBuffer[j].Position;
            float len = length(b2g);
            float3 b2gNormalize = normalize(b2g);
        
            float offset = len - BallBuffer[j].Radius;
            if (offset < 0)
            {
                float3 targetPos = BallBuffer[j].Position + b2gNormalize * BallBuffer[j].Radius;
                PositionBuffer[idb] = targetPos;
                PredictedBuffer[idb] = targetPos;
                VelocitiesBuffer[idb] = float3(0, 0, 0);
                break;
            }
        }
    }
    
    // Do Constraints ***************
    float stepDT = 1.0f / 4.0f;
    
    // distance constraints
    int dconsIndexOffset = idx * (BoneCounts - 1);
    float invMass = 1.0f / Mass;
    float sum = Mass * 2.0f;
    for (i = 0; i < 4; i++)  // 4 iteration
    {
        for (int j = 0; j < BoneCounts - 1; j++)   // 3 dcons
        {
            int i1 = DconsBuffer[dconsIndexOffset + j].i1 + idx * BoneCounts;
            int i0 = DconsBuffer[dconsIndexOffset + j].i0 + idx * BoneCounts;
            float3 n = PredictedBuffer[i1] - PredictedBuffer[i0];
            float d = length(n);
            n = normalize(n);

            float3 corr = DconsBuffer[dconsIndexOffset + j].ElasticModulus * n * (d - DconsBuffer[dconsIndexOffset + j].RestLength) * sum;

            PredictedBuffer[i0] += invMass * corr * stepDT;

            PredictedBuffer[i1] -= invMass * corr * stepDT;
        }
    }
    
    // fixed constraints
    PositionBuffer[FconsBuffer[idx].i0 + idx * BoneCounts] = FconsBuffer[idx].fixedPos;
    PredictedBuffer[FconsBuffer[idx].i0 + idx * BoneCounts] = FconsBuffer[idx].fixedPos;
    
    
    // UpdateVelocities ****************
    float threshold = StopThreshold * dt;
    for (i = 0; i < BoneCounts; i++)
    {
        int boneIndex = idx * BoneCounts + i;
    
        float3 dist = PredictedBuffer[boneIndex] - PositionBuffer[boneIndex];
        VelocitiesBuffer[boneIndex] = dist / dt;
        if (length(VelocitiesBuffer[boneIndex]) < threshold)
            VelocitiesBuffer[boneIndex] = float3(0, 0, 0);
    }
    
    // Update Positions ********************
    for (i = 0; i < BoneCounts; i++)
    {
        int boneIndex = idx * BoneCounts + i;
        PositionBuffer[boneIndex] = PredictedBuffer[boneIndex];
    }

}

[numthreads(XThreads, 1, 1)]
void UpdateMesh(uint3 id : SV_DispatchThreadID, uint3 idInGroup : SV_GroupThreadID)
{
    int idx = (GridsVisibleBuffer[id.y].idOffset + idInGroup.x);
    
    int boneOffset = idx * BoneCounts;
    int offsetOffset = idx * (BoneCounts - 1);
    int index = 0;
    for (int i = 0; i < (BoneCounts * 2 - 1) - 2; i += 2)
    {
        ResultPosBuffer[i + IndexOffsetBuffer[idx]] = PositionBuffer[boneOffset + index] + OffsetBuffer[offsetOffset + index];
        ResultPosBuffer[i + 1 + IndexOffsetBuffer[idx]] = PositionBuffer[boneOffset + index] - OffsetBuffer[offsetOffset + index];
        ++index;
    }
    ResultPosBuffer[(BoneCounts * 2 - 1) - 1 + IndexOffsetBuffer[idx]] = PositionBuffer[boneOffset + index];
}

StructuredBuffer<PBDGrid> GridsAllBuffer;
RWStructuredBuffer<int> bufferWithArgs;
RWStructuredBuffer<int> bufferWithArgsDrawIndirect;

float3 camPos;
float3 camDir;
float camHalfFov;
float4x4 _Matrix_VP;
Texture2D _DepthTex;

[numthreads(32, 1, 1)]
void GridCulling(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    //https://math.stackexchange.com/questions/237369/given-this-transformation-matrix-how-do-i-decompose-it-into-translation-rotati/417813
    float3 itemPos = GridsAllBuffer[index].pos;
    float3 itemDir = normalize(itemPos - camPos);
    float rot = dot(camDir, itemDir);
    
    float4 clipPos = mul(_Matrix_VP, float4(itemPos - camDir * 0.2, 1));
    
    //view frustrum
    if (max(abs(clipPos.x), abs(clipPos.y)) > clipPos.w + 0.7)
        return;
    
    clipPos.xyz /= clipPos.w;
    clipPos.xy = clipPos.xy * 0.5 + 0.5;
    
    float scWid = 0.2 / (tan(camHalfFov * 3.1415926 / 180) * clipPos.w) * 1024;
    
    uint mips = (uint) clamp(log2(scWid), 0, 7);
    
    uint texScale = 1 << mips;
    uint2 uv = uint2(clipPos.xy * (1024 / texScale));
    
    float minD = min(min(_DepthTex.mips[mips][uv.xy + uint2(0, 0)].r, _DepthTex.mips[mips][uv.xy + uint2(0, 1)].r), min(_DepthTex.mips[mips][uv.xy + uint2(1, 0)].r, _DepthTex.mips[mips][uv.xy + uint2(1, 1)].r));
    if (minD > clipPos.z)
        return;
    
    float dist = distance(itemPos, camPos);
    if (dist >= 90)
        return;
    
    int currentIndex;
    InterlockedAdd(bufferWithArgs[1], 1, currentIndex);
    InterlockedAdd(bufferWithArgsDrawIndirect[1], 1);
    GridsVisibleBuffer[currentIndex] = GridsAllBuffer[id.x];
}